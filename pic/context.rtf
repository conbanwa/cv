{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red15\green112\blue1;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red144\green1\blue18;\red32\green108\blue135;\red101\green76\blue29;\red0\green0\blue109;
\red157\green0\blue210;\red19\green118\blue70;}
{\*\expandedcolortbl;;\cssrgb\c0\c50196\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c63922\c8235\c8235;\cssrgb\c14902\c49804\c60000;\cssrgb\c47451\c36863\c14902;\cssrgb\c0\c6275\c50196;
\cssrgb\c68627\c0\c85882;\cssrgb\c3529\c52549\c34510;}
\paperw11900\paperh16840\margl1440\margr1440\vieww29060\viewh17760\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 // Copyright 2014 The Go Authors. All rights reserved.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Use of this source code is governed by a BSD-style\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // license that can be found in the LICENSE file.\cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // Package context defines the Context type, which carries deadlines,\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // cancellation signals, and other request-scoped values across API boundaries\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // and between processes.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Incoming requests to a server should create a Context, and outgoing\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // calls to servers should accept a Context. The chain of function\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // calls between them must propagate the Context, optionally replacing\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // it with a derived Context created using WithCancel, WithDeadline,\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // WithTimeout, or WithValue. When a Context is canceled, all\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Contexts derived from it are also canceled.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // The WithCancel, WithDeadline, and WithTimeout functions take a\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Context (the parent) and return a derived Context (the child) and a\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // CancelFunc. Calling the CancelFunc cancels the child and its\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // children, removes the parent's reference to the child, and stops\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // any associated timers. Failing to call the CancelFunc leaks the\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // child and its children until the parent is canceled or the timer\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // fires. The go vet tool checks that CancelFuncs are used on all\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // control-flow paths.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Programs that use Contexts should follow these rules to keep interfaces\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // consistent across packages and enable static analysis tools to check context\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // propagation:\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Do not store Contexts inside a struct type; instead, pass a Context\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // explicitly to each function that needs it. The Context should be the first\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // parameter, typically named ctx:\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //  func DoSomething(ctx context.Context, arg Arg) error \{\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      // ... use ctx ...\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //  \}\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Do not pass a nil Context, even if a function permits it. Pass context.TODO\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // if you are unsure about which Context to use.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Use context Values only for request-scoped data that transits processes and\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // APIs, not for passing optional parameters to functions.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // The same Context may be passed to functions running in different goroutines;\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Contexts are safe for simultaneous use by multiple goroutines.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // See https://blog.golang.org/context for example code for a server that uses\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Contexts.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 package\cf0 \cb3 \strokec4  context\cb1 \
\
\cf5 \cb3 \strokec5 import\cf0 \cb3 \strokec4  (\cb1 \
\cb3     \cf6 \cb3 \strokec6 "errors"\cf0 \cb1 \strokec4 \
\cb3     \cf6 \cb3 \strokec6 "internal/reflectlite"\cf0 \cb1 \strokec4 \
\cb3     \cf6 \cb3 \strokec6 "sync"\cf0 \cb1 \strokec4 \
\cb3     \cf6 \cb3 \strokec6 "sync/atomic"\cf0 \cb1 \strokec4 \
\cb3     \cf6 \cb3 \strokec6 "time"\cf0 \cb1 \strokec4 \
\cb3 )\cb1 \
\
\cf2 \cb3 \strokec2 // A Context carries a deadline, a cancellation signal, and other values across\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // API boundaries.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Context's methods may be called by multiple goroutines simultaneously.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 Context\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 interface\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf2 \strokec2 // Deadline returns the time when work done on behalf of this context\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // should be canceled. Deadline returns ok==false when no deadline is\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // set. Successive calls to Deadline return the same results.\cf0 \cb1 \strokec4 \
\cb3     \cf8 \cb3 \strokec8 Deadline\cf0 \cb3 \strokec4 () (deadline time.Time, ok \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 )\cb1 \
\
\cb3     \cf2 \strokec2 // Done returns a channel that's closed when work done on behalf of this\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // context should be canceled. Done may return nil if this context can\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // never be canceled. Successive calls to Done return the same value.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // The close of the Done channel may happen asynchronously,\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // after the cancel function returns.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // WithCancel arranges for Done to be closed when cancel is called;\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // WithDeadline arranges for Done to be closed when the deadline\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // expires; WithTimeout arranges for Done to be closed when the timeout\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // elapses.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // Done is provided for use in select statements:\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // Stream generates values with DoSomething and sends them to out\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // until DoSomething returns an error or ctx.Done is closed.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  func Stream(ctx context.Context, out chan<- Value) error \{\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //      for \{\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          v, err := DoSomething(ctx)\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          if err != nil \{\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //              return err\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          \}\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          select \{\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          case <-ctx.Done():\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //              return ctx.Err()\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          case out <- v:\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //          \}\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //      \}\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  \}\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // See https://blog.golang.org/pipelines for more examples of how to use\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // a Done channel for cancellation.\cf0 \cb1 \strokec4 \
\cb3     \cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 () <-\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\}\cb1 \
\
\cb3     \cf2 \strokec2 // If Done is not yet closed, Err returns nil.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // If Done is closed, Err returns a non-nil error explaining why:\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // Canceled if the context was canceled\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // or DeadlineExceeded if the context's deadline passed.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // After Err returns a non-nil error, successive calls to Err return the same error.\cf0 \cb1 \strokec4 \
\cb3     \cf8 \cb3 \strokec8 Err\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 error\cf0 \cb1 \strokec4 \
\
\cb3     \cf2 \strokec2 // Value returns the value associated with this context for key, or nil\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // if no value is associated with key. Successive calls to Value with\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // the same key returns the same result.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // Use context values only for request-scoped data that transits\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // processes and API boundaries, not for passing optional parameters to\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // functions.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // A key identifies a specific value in a Context. Functions that wish\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // to store values in Context typically allocate a key in a global\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // variable then use that key as the argument to context.WithValue and\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // Context.Value. A key can be any type that supports equality;\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // packages should define keys as an unexported type to avoid\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // collisions.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // Packages that define a Context key should provide type-safe accessors\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 // for the values stored using that key:\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // Package user defines a User type that's stored in Contexts.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  package user\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  import "context"\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // User is the type of value stored in the Contexts.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  type User struct \{...\}\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // key is an unexported type for keys defined in this package.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // This prevents collisions with keys defined in other packages.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  type key int\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // userKey is the key for user.User values in Contexts. It is\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // unexported; clients use user.NewContext and user.FromContext\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // instead of using this key directly.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  var userKey key\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // NewContext returns a new Context that carries value u.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  func NewContext(ctx context.Context, u *User) context.Context \{\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //      return context.WithValue(ctx, userKey, u)\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  \}\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  // FromContext returns the User value stored in ctx, if any.\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  func FromContext(ctx context.Context) (*User, bool) \{\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //      u, ok := ctx.Value(userKey).(*User)\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //      return u, ok\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 //  \}\cf0 \cb1 \strokec4 \
\cb3     \cf8 \cb3 \strokec8 Value\cf0 \cb3 \strokec4 (key any) any\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // Canceled is the error returned by Context.Err when the context is canceled.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 var\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 Canceled\cf0 \cb3 \strokec4  = errors.\cf8 \cb3 \strokec8 New\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "context canceled"\cf0 \cb3 \strokec4 )\cb1 \
\
\cf2 \cb3 \strokec2 // DeadlineExceeded is the error returned by Context.Err when the context's\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // deadline passes.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 var\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 DeadlineExceeded\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4  = deadlineExceededError\{\}\cb1 \
\
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 deadlineExceededError\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (deadlineExceededError) \cf8 \cb3 \strokec8 Error\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4    \{ \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf6 \cb3 \strokec6 "context deadline exceeded"\cf0 \cb3 \strokec4  \}\cb1 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (deadlineExceededError) \cf8 \cb3 \strokec8 Timeout\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4    \{ \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 true\cf0 \cb3 \strokec4  \}\cb1 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (deadlineExceededError) \cf8 \cb3 \strokec8 Temporary\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4  \{ \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 true\cf0 \cb3 \strokec4  \}\cb1 \
\
\cf2 \cb3 \strokec2 // An emptyCtx is never canceled, has no values, and has no deadline. It is not\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // struct\{\}, since vars of this type must have distinct addresses.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 emptyCtx\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 int\cf0 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (*emptyCtx) \cf8 \cb3 \strokec8 Deadline\cf0 \cb3 \strokec4 () (deadline time.Time, ok \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 ) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (*emptyCtx) \cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 () <-\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\} \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (*emptyCtx) \cf8 \cb3 \strokec8 Err\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (*emptyCtx) \cf8 \cb3 \strokec8 Value\cf0 \cb3 \strokec4 (key any) any \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (e *emptyCtx) \cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 switch\cf0 \cb3 \strokec4  e \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  background:\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf6 \cb3 \strokec6 "context.Background"\cf0 \cb1 \strokec4 \
\cb3     \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  todo:\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf6 \cb3 \strokec6 "context.TODO"\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf6 \cb3 \strokec6 "unknown empty Context"\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 var\cf0 \cb3 \strokec4  (\cb1 \
\cb3     \cf9 \cb3 \strokec9 background\cf0 \cb3 \strokec4  = \cf8 \cb3 \strokec8 new\cf0 \cb3 \strokec4 (emptyCtx)\cb1 \
\cb3     \cf9 \cb3 \strokec9 todo\cf0 \cb3 \strokec4        = \cf8 \cb3 \strokec8 new\cf0 \cb3 \strokec4 (emptyCtx)\cb1 \
\cb3 )\cb1 \
\
\cf2 \cb3 \strokec2 // Background returns a non-nil, empty Context. It is never canceled, has no\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // values, and has no deadline. It is typically used by the main function,\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // initialization, and tests, and as the top-level Context for incoming\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // requests.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 Background\cf0 \cb3 \strokec4 () Context \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  background\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // TODO returns a non-nil, empty Context. Code should use context.TODO when\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // it's unclear which Context to use or it is not yet available (because the\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // surrounding function has not yet been extended to accept a Context\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // parameter).\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 TODO\cf0 \cb3 \strokec4 () Context \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  todo\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // A CancelFunc tells an operation to abandon its work.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // A CancelFunc does not wait for the work to stop.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // A CancelFunc may be called by multiple goroutines simultaneously.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // After the first call, subsequent calls to a CancelFunc do nothing.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 CancelFunc\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4 ()\cb1 \
\
\cf2 \cb3 \strokec2 // WithCancel returns a copy of parent with a new Done channel. The returned\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // context's Done channel is closed when the returned cancel function is called\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // or when the parent context's Done channel is closed, whichever happens first.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Canceling this context releases resources associated with it, so code should\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // call cancel as soon as the operations running in this Context complete.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 WithCancel\cf0 \cb3 \strokec4 (parent Context) (ctx Context, cancel CancelFunc) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  parent == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 panic\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "cannot create context from nil parent"\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \}\cb1 \
\cb3     \cf9 \cb3 \strokec9 c\cf0 \cb3 \strokec4  := \cf8 \cb3 \strokec8 newCancelCtx\cf0 \cb3 \strokec4 (parent)\cb1 \
\cb3     \cf8 \cb3 \strokec8 propagateCancel\cf0 \cb3 \strokec4 (parent, &c)\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  &c, \cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4 () \{ c.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 true\cf0 \cb3 \strokec4 , Canceled) \}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // newCancelCtx returns an initialized cancelCtx.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 newCancelCtx\cf0 \cb3 \strokec4 (parent Context) cancelCtx \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  cancelCtx\{Context: parent\}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // goroutines counts the number of goroutines ever created; for testing.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 var\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 goroutines\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 int32\cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // propagateCancel arranges for child to be canceled when parent is.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 propagateCancel\cf0 \cb3 \strokec4 (parent Context, child canceler) \{\cb1 \
\cb3     \cf9 \cb3 \strokec9 done\cf0 \cb3 \strokec4  := parent.\cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  done == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf2 \strokec2 // parent is never canceled\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\
\cb3     \cf10 \cb3 \strokec10 select\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  <-done:\cb1 \
\cb3         \cf2 \strokec2 // parent is already canceled\cf0 \cb1 \strokec4 \
\cb3         child.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 false\cf0 \cb3 \strokec4 , parent.\cf8 \cb3 \strokec8 Err\cf0 \cb3 \strokec4 ())\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb1 \strokec4 \
\cb3     \cf10 \cb3 \strokec10 default\cf0 \cb3 \strokec4 :\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 p\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 ok\cf0 \cb3 \strokec4  := \cf8 \cb3 \strokec8 parentCancelCtx\cf0 \cb3 \strokec4 (parent); ok \{\cb1 \
\cb3         p.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3         \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  p.err != \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3             \cf2 \strokec2 // parent has already been canceled\cf0 \cb1 \strokec4 \
\cb3             child.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 false\cf0 \cb3 \strokec4 , p.err)\cb1 \
\cb3         \} \cf10 \cb3 \strokec10 else\cf0 \cb3 \strokec4  \{\cb1 \
\cb3             \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  p.children == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3                 \cf9 \cb3 \strokec9 p.children\cf0 \cb3 \strokec4  = \cf8 \cb3 \strokec8 make\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 map\cf0 \cb3 \strokec4 [canceler]\cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\cb3             \}\cb1 \
\cb3             p.children[child] = \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\}\{\}\cb1 \
\cb3         \}\cb1 \
\cb3         p.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \} \cf10 \cb3 \strokec10 else\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         atomic.\cf8 \cb3 \strokec8 AddInt32\cf0 \cb3 \strokec4 (&goroutines, +\cf11 \cb3 \strokec11 1\cf0 \cb3 \strokec4 )\cb1 \
\cb3         \cf10 \cb3 \strokec10 go\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4 () \{\cb1 \
\cb3             \cf10 \cb3 \strokec10 select\cf0 \cb3 \strokec4  \{\cb1 \
\cb3             \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  <-parent.\cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 ():\cb1 \
\cb3                 child.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 false\cf0 \cb3 \strokec4 , parent.\cf8 \cb3 \strokec8 Err\cf0 \cb3 \strokec4 ())\cb1 \
\cb3             \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  <-child.\cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 ():\cb1 \
\cb3             \}\cb1 \
\cb3         \}()\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // &cancelCtxKey is the key that a cancelCtx returns itself for.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 var\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 cancelCtxKey\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 int\cf0 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // parentCancelCtx returns the underlying *cancelCtx for parent.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // It does this by looking up parent.Value(&cancelCtxKey) to find\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // the innermost enclosing *cancelCtx and then checking whether\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // parent.Done() matches that *cancelCtx. (If not, the *cancelCtx\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // has been wrapped in a custom implementation providing a\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // different done channel, in which case we should not bypass it.)\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 parentCancelCtx\cf0 \cb3 \strokec4 (parent Context) (*cancelCtx, \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 ) \{\cb1 \
\cb3     \cf9 \cb3 \strokec9 done\cf0 \cb3 \strokec4  := parent.\cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  done == closedchan || done == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4 , \cf5 \cb3 \strokec5 false\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     \cf9 \cb3 \strokec9 p\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 ok\cf0 \cb3 \strokec4  := parent.\cf8 \cb3 \strokec8 Value\cf0 \cb3 \strokec4 (&cancelCtxKey).(*cancelCtx)\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  !ok \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4 , \cf5 \cb3 \strokec5 false\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     \cf9 \cb3 \strokec9 pdone\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 _\cf0 \cb3 \strokec4  := p.done.\cf8 \cb3 \strokec8 Load\cf0 \cb3 \strokec4 ().(\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  pdone != done \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4 , \cf5 \cb3 \strokec5 false\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  p, \cf5 \cb3 \strokec5 true\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // removeChild removes a context from its parent.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 removeChild\cf0 \cb3 \strokec4 (parent Context, child canceler) \{\cb1 \
\cb3     \cf9 \cb3 \strokec9 p\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 ok\cf0 \cb3 \strokec4  := \cf8 \cb3 \strokec8 parentCancelCtx\cf0 \cb3 \strokec4 (parent)\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  !ok \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     p.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  p.children != \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 delete\cf0 \cb3 \strokec4 (p.children, child)\cb1 \
\cb3     \}\cb1 \
\cb3     p.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // A canceler is a context type that can be canceled directly. The\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // implementations are *cancelCtx and *timerCtx.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 canceler\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 interface\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (removeFromParent \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 , err \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 () <-\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // closedchan is a reusable closed channel.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 var\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 closedchan\cf0 \cb3 \strokec4  = \cf8 \cb3 \strokec8 make\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 init\cf0 \cb3 \strokec4 () \{\cb1 \
\cb3     \cf8 \cb3 \strokec8 close\cf0 \cb3 \strokec4 (closedchan)\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // A cancelCtx can be canceled. When canceled, it also cancels any children\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // that implement canceler.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 cancelCtx\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     Context\cb1 \
\
\cb3     mu       sync.Mutex            \cf2 \strokec2 // protects following fields\cf0 \cb1 \strokec4 \
\cb3     done     atomic.Value          \cf2 \strokec2 // of chan struct\{\}, created lazily, closed by first cancel call\cf0 \cb1 \strokec4 \
\cb3     children \cf5 \cb3 \strokec5 map\cf0 \cb3 \strokec4 [canceler]\cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\} \cf2 \strokec2 // set to nil by the first cancel call\cf0 \cb1 \strokec4 \
\cb3     err      \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4                  \cf2 \strokec2 // set to non-nil by the first cancel call\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *cancelCtx) \cf8 \cb3 \strokec8 Value\cf0 \cb3 \strokec4 (key any) any \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  key == &cancelCtxKey \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 value\cf0 \cb3 \strokec4 (c.Context, key)\cb1 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *cancelCtx) \cf8 \cb3 \strokec8 Done\cf0 \cb3 \strokec4 () <-\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\} \{\cb1 \
\cb3     \cf9 \cb3 \strokec9 d\cf0 \cb3 \strokec4  := c.done.\cf8 \cb3 \strokec8 Load\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  d != \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  d.(\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\cb3     \}\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 defer\cf0 \cb3 \strokec4  c.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf9 \cb3 \strokec9 d\cf0 \cb3 \strokec4  = c.done.\cf8 \cb3 \strokec8 Load\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  d == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf9 \cb3 \strokec9 d\cf0 \cb3 \strokec4  = \cf8 \cb3 \strokec8 make\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\cb3         c.done.\cf8 \cb3 \strokec8 Store\cf0 \cb3 \strokec4 (d)\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  d.(\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *cancelCtx) \cf8 \cb3 \strokec8 Err\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf9 \cb3 \strokec9 err\cf0 \cb3 \strokec4  := c.err\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  err\cb1 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 stringer\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 interface\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 string\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 contextName\cf0 \cb3 \strokec4 (c Context) \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 s\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 ok\cf0 \cb3 \strokec4  := c.(stringer); ok \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  s.\cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  reflectlite.\cf8 \cb3 \strokec8 TypeOf\cf0 \cb3 \strokec4 (c).\cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 ()\cb1 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *cancelCtx) \cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 contextName\cf0 \cb3 \strokec4 (c.Context) + \cf6 \cb3 \strokec6 ".WithCancel"\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // cancel closes c.done, cancels each of c's children, and, if\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // removeFromParent is true, removes c from its parent's children.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *cancelCtx) \cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (removeFromParent \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 , err \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4 ) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  err == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 panic\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "context: internal error: missing cancel error"\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \}\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  c.err != \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         c.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf2 \strokec2 // already canceled\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     \cf9 \cb3 \strokec9 c.err\cf0 \cb3 \strokec4  = err\cb1 \
\cb3     \cf9 \cb3 \strokec9 d\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 _\cf0 \cb3 \strokec4  := c.done.\cf8 \cb3 \strokec8 Load\cf0 \cb3 \strokec4 ().(\cf5 \cb3 \strokec5 chan\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4 \{\})\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  d == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         c.done.\cf8 \cb3 \strokec8 Store\cf0 \cb3 \strokec4 (closedchan)\cb1 \
\cb3     \} \cf10 \cb3 \strokec10 else\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 close\cf0 \cb3 \strokec4 (d)\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 for\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 child\cf0 \cb3 \strokec4  := \cf10 \cb3 \strokec10 range\cf0 \cb3 \strokec4  c.children \{\cb1 \
\cb3         \cf2 \strokec2 // NOTE: acquiring the child's lock while holding parent's lock.\cf0 \cb1 \strokec4 \
\cb3         child.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 false\cf0 \cb3 \strokec4 , err)\cb1 \
\cb3     \}\cb1 \
\cb3     \cf9 \cb3 \strokec9 c.children\cf0 \cb3 \strokec4  = \cf5 \cb3 \strokec5 nil\cf0 \cb1 \strokec4 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  removeFromParent \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 removeChild\cf0 \cb3 \strokec4 (c.Context, c)\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // WithDeadline returns a copy of the parent context with the deadline adjusted\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // to be no later than d. If the parent's deadline is already earlier than d,\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // WithDeadline(parent, d) is semantically equivalent to parent. The returned\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // context's Done channel is closed when the deadline expires, when the returned\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // cancel function is called, or when the parent context's Done channel is\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // closed, whichever happens first.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Canceling this context releases resources associated with it, so code should\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // call cancel as soon as the operations running in this Context complete.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 WithDeadline\cf0 \cb3 \strokec4 (parent Context, d time.Time) (Context, CancelFunc) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  parent == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 panic\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "cannot create context from nil parent"\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 cur\cf0 \cb3 \strokec4 , \cf9 \cb3 \strokec9 ok\cf0 \cb3 \strokec4  := parent.\cf8 \cb3 \strokec8 Deadline\cf0 \cb3 \strokec4 (); ok && cur.\cf8 \cb3 \strokec8 Before\cf0 \cb3 \strokec4 (d) \{\cb1 \
\cb3         \cf2 \strokec2 // The current deadline is already sooner than the new one.\cf0 \cb1 \strokec4 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 WithCancel\cf0 \cb3 \strokec4 (parent)\cb1 \
\cb3     \}\cb1 \
\cb3     \cf9 \cb3 \strokec9 c\cf0 \cb3 \strokec4  := &timerCtx\{\cb1 \
\cb3         cancelCtx: \cf8 \cb3 \strokec8 newCancelCtx\cf0 \cb3 \strokec4 (parent),\cb1 \
\cb3         deadline:  d,\cb1 \
\cb3     \}\cb1 \
\cb3     \cf8 \cb3 \strokec8 propagateCancel\cf0 \cb3 \strokec4 (parent, c)\cb1 \
\cb3     \cf9 \cb3 \strokec9 dur\cf0 \cb3 \strokec4  := time.\cf8 \cb3 \strokec8 Until\cf0 \cb3 \strokec4 (d)\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  dur <= \cf11 \cb3 \strokec11 0\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         c.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 true\cf0 \cb3 \strokec4 , DeadlineExceeded) \cf2 \strokec2 // deadline has already passed\cf0 \cb1 \strokec4 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c, \cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4 () \{ c.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 false\cf0 \cb3 \strokec4 , Canceled) \}\cb1 \
\cb3     \}\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 defer\cf0 \cb3 \strokec4  c.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  c.err == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf9 \cb3 \strokec9 c.timer\cf0 \cb3 \strokec4  = time.\cf8 \cb3 \strokec8 AfterFunc\cf0 \cb3 \strokec4 (dur, \cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4 () \{\cb1 \
\cb3             c.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 true\cf0 \cb3 \strokec4 , DeadlineExceeded)\cb1 \
\cb3         \})\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c, \cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4 () \{ c.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 true\cf0 \cb3 \strokec4 , Canceled) \}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // A timerCtx carries a timer and a deadline. It embeds a cancelCtx to\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // implement Done and Err. It implements cancel by stopping its timer then\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // delegating to cancelCtx.cancel.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 timerCtx\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     cancelCtx\cb1 \
\cb3     timer *time.Timer \cf2 \strokec2 // Under cancelCtx.mu.\cf0 \cb1 \strokec4 \
\
\cb3     deadline time.Time\cb1 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *timerCtx) \cf8 \cb3 \strokec8 Deadline\cf0 \cb3 \strokec4 () (deadline time.Time, ok \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 ) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c.deadline, \cf5 \cb3 \strokec5 true\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *timerCtx) \cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 contextName\cf0 \cb3 \strokec4 (c.cancelCtx.Context) + \cf6 \cb3 \strokec6 ".WithDeadline("\cf0 \cb3 \strokec4  +\cb1 \
\cb3         c.deadline.\cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () + \cf6 \cb3 \strokec6 " ["\cf0 \cb3 \strokec4  +\cb1 \
\cb3         time.\cf8 \cb3 \strokec8 Until\cf0 \cb3 \strokec4 (c.deadline).\cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () + \cf6 \cb3 \strokec6 "])"\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *timerCtx) \cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (removeFromParent \cf7 \cb3 \strokec7 bool\cf0 \cb3 \strokec4 , err \cf7 \cb3 \strokec7 error\cf0 \cb3 \strokec4 ) \{\cb1 \
\cb3     c.cancelCtx.\cf8 \cb3 \strokec8 cancel\cf0 \cb3 \strokec4 (\cf5 \cb3 \strokec5 false\cf0 \cb3 \strokec4 , err)\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  removeFromParent \{\cb1 \
\cb3         \cf2 \strokec2 // Remove this timerCtx from its parent cancelCtx's children.\cf0 \cb1 \strokec4 \
\cb3         \cf8 \cb3 \strokec8 removeChild\cf0 \cb3 \strokec4 (c.cancelCtx.Context, c)\cb1 \
\cb3     \}\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Lock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  c.timer != \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         c.timer.\cf8 \cb3 \strokec8 Stop\cf0 \cb3 \strokec4 ()\cb1 \
\cb3         \cf9 \cb3 \strokec9 c.timer\cf0 \cb3 \strokec4  = \cf5 \cb3 \strokec5 nil\cf0 \cb1 \strokec4 \
\cb3     \}\cb1 \
\cb3     c.mu.\cf8 \cb3 \strokec8 Unlock\cf0 \cb3 \strokec4 ()\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Canceling this context releases resources associated with it, so code should\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // call cancel as soon as the operations running in this Context complete:\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //  func slowOperationWithTimeout(ctx context.Context) (Result, error) \{\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      defer cancel()  // releases resources if slowOperation completes before timeout elapses\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      return slowOperation(ctx)\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //  \}\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 WithTimeout\cf0 \cb3 \strokec4 (parent Context, timeout time.Duration) (Context, CancelFunc) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 WithDeadline\cf0 \cb3 \strokec4 (parent, time.\cf8 \cb3 \strokec8 Now\cf0 \cb3 \strokec4 ().\cf8 \cb3 \strokec8 Add\cf0 \cb3 \strokec4 (timeout))\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // WithValue returns a copy of parent in which the value associated with key is\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // val.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Use context Values only for request-scoped data that transits processes and\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // APIs, not for passing optional parameters to functions.\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // The provided key must be comparable and should not be of type\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // string or any other built-in type to avoid collisions between\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // packages using context. Users of WithValue should define their own\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // types for keys. To avoid allocating when assigning to an\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // interface\{\}, context keys often have concrete type\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // struct\{\}. Alternatively, exported context key variables' static\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // type should be a pointer or interface.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 WithValue\cf0 \cb3 \strokec4 (parent Context, key, val any) Context \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  parent == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 panic\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "cannot create context from nil parent"\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  key == \cf5 \cb3 \strokec5 nil\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 panic\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "nil key"\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  !reflectlite.\cf8 \cb3 \strokec8 TypeOf\cf0 \cb3 \strokec4 (key).\cf8 \cb3 \strokec8 Comparable\cf0 \cb3 \strokec4 () \{\cb1 \
\cb3         \cf8 \cb3 \strokec8 panic\cf0 \cb3 \strokec4 (\cf6 \cb3 \strokec6 "key is not comparable"\cf0 \cb3 \strokec4 )\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  &valueCtx\{parent, key, val\}\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // A valueCtx carries a key-value pair. It implements Value for that key and\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // delegates all other calls to the embedded Context.\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 type\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 valueCtx\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 struct\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     Context\cb1 \
\cb3     key, val any\cb1 \
\cb3 \}\cb1 \
\
\cf2 \cb3 \strokec2 // stringify tries a bit to stringify v, without using fmt, since we don't\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // want context depending on the unicode tables. This is only used by\cf0 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // *valueCtx.String().\cf0 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 stringify\cf0 \cb3 \strokec4 (v any) \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 switch\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 s\cf0 \cb3 \strokec4  := v.(type) \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  stringer:\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  s.\cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 ()\cb1 \
\cb3     \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4 :\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  s\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf6 \cb3 \strokec6 "<not Stringer>"\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *valueCtx) \cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () \cf7 \cb3 \strokec7 string\cf0 \cb3 \strokec4  \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 contextName\cf0 \cb3 \strokec4 (c.Context) + \cf6 \cb3 \strokec6 ".WithValue(type "\cf0 \cb3 \strokec4  +\cb1 \
\cb3         reflectlite.\cf8 \cb3 \strokec8 TypeOf\cf0 \cb3 \strokec4 (c.key).\cf8 \cb3 \strokec8 String\cf0 \cb3 \strokec4 () +\cb1 \
\cb3         \cf6 \cb3 \strokec6 ", val "\cf0 \cb3 \strokec4  + \cf8 \cb3 \strokec8 stringify\cf0 \cb3 \strokec4 (c.val) + \cf6 \cb3 \strokec6 ")"\cf0 \cb1 \strokec4 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  (c *valueCtx) \cf8 \cb3 \strokec8 Value\cf0 \cb3 \strokec4 (key any) any \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  c.key == key \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c.val\cb1 \
\cb3     \}\cb1 \
\cb3     \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 value\cf0 \cb3 \strokec4 (c.Context, key)\cb1 \
\cb3 \}\cb1 \
\
\cf5 \cb3 \strokec5 func\cf0 \cb3 \strokec4  \cf8 \cb3 \strokec8 value\cf0 \cb3 \strokec4 (c Context, key any) any \{\cb1 \
\cb3     \cf10 \cb3 \strokec10 for\cf0 \cb3 \strokec4  \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 switch\cf0 \cb3 \strokec4  \cf9 \cb3 \strokec9 ctx\cf0 \cb3 \strokec4  := c.(type) \{\cb1 \
\cb3         \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  *valueCtx:\cb1 \
\cb3             \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  key == ctx.key \{\cb1 \
\cb3                 \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  ctx.val\cb1 \
\cb3             \}\cb1 \
\cb3             \cf9 \cb3 \strokec9 c\cf0 \cb3 \strokec4  = ctx.Context\cb1 \
\cb3         \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  *cancelCtx:\cb1 \
\cb3             \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  key == &cancelCtxKey \{\cb1 \
\cb3                 \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c\cb1 \
\cb3             \}\cb1 \
\cb3             \cf9 \cb3 \strokec9 c\cf0 \cb3 \strokec4  = ctx.Context\cb1 \
\cb3         \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  *timerCtx:\cb1 \
\cb3             \cf10 \cb3 \strokec10 if\cf0 \cb3 \strokec4  key == &cancelCtxKey \{\cb1 \
\cb3                 \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  &ctx.cancelCtx\cb1 \
\cb3             \}\cb1 \
\cb3             \cf9 \cb3 \strokec9 c\cf0 \cb3 \strokec4  = ctx.Context\cb1 \
\cb3         \cf10 \cb3 \strokec10 case\cf0 \cb3 \strokec4  *emptyCtx:\cb1 \
\cb3             \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  \cf5 \cb3 \strokec5 nil\cf0 \cb1 \strokec4 \
\cb3         \cf10 \cb3 \strokec10 default\cf0 \cb3 \strokec4 :\cb1 \
\cb3             \cf10 \cb3 \strokec10 return\cf0 \cb3 \strokec4  c.\cf8 \cb3 \strokec8 Value\cf0 \cb3 \strokec4 (key)\cb1 \
\cb3         \}\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\
}